param(
  [switch]$Isolated,
  [switch]$Pack,
  [switch]$Release
)

$ErrorActionPreference = 'Stop'
$ModuleName = "Authentication"
$ModulePrefix = "Microsoft.Graph"
$netStandard = "netstandard2.0"
$netApp = "net6.0"
$netFx = "net472"
$copyExtensions = @('.dll', '.pdb')

# Source code locations
$coreSrc = Join-Path $PSScriptRoot "../$ModuleName.Core"
$cmdletsSrc = Join-Path $PSScriptRoot "../$ModuleName"

# Generated output locations
$outDir = Join-Path $PSScriptRoot "artifacts"
$outDeps = Join-Path $outDir "Dependencies"
$outCore = Join-Path $outDeps "Core"
$outDesktop = Join-Path $outDeps "Desktop"

if ($PSEdition -ne 'Core') {
  Write-Error 'This script requires PowerShell Core to execute. [Note] Generated cmdlets will work in both PowerShell Core or Windows PowerShell.'
}

$Configuration = 'Debug'
if ($Release) {
  $Configuration = 'Release'
}

if (-not $Isolated) {
  Write-Host -ForegroundColor Green 'Creating isolated process...'
  $pwsh = [System.Diagnostics.Process]::GetCurrentProcess().Path
  & "$pwsh" -NonInteractive -NoLogo -NoProfile -File $MyInvocation.MyCommand.Path @PSBoundParameters -Isolated

  if ($LastExitCode -ne 0) {
    # Build failed. Don't attempt to run the module.
    return
  }

  if ($Pack) {
    . (Join-Path $PSScriptRoot 'pack-module.ps1')
    if ($LastExitCode -ne 0) {
      # Packing failed. Don't attempt to run the module.
      return
    }
  }
  return
}

# Clean build folders.
Write-Host -ForegroundColor Green 'Cleaning build folders...'
$null = Remove-Item -Path "$coreSrc/bin", "$coreSrc/obj" -Recurse -ErrorAction Ignore
$null = Remove-Item -Path "$cmdletsSrc/bin", "$cmdletsSrc/obj" -Recurse -ErrorAction Ignore

if ((Test-Path "$cmdletsSrc/bin") -or (Test-Path "$cmdletsSrc/obj")) {
  Write-Host -ForegroundColor Cyan 'Did you forget to exit your isolated module session before rebuilding?'
  Write-Error 'Unable to clean ''bin'' or ''obj'' folder. A process may have an open handle.'
}

Write-Host -ForegroundColor Green 'Compiling module...'
# Build authentication.core for each framework.
Push-Location $coreSrc
dotnet publish -c $Configuration -f $netStandard --verbosity quiet /nologo
dotnet publish -c $Configuration -f $netApp --verbosity quiet /nologo
dotnet publish -c $Configuration -f $netFx --verbosity quiet /nologo
Pop-Location

# Build authentication.
Push-Location $cmdletsSrc
dotnet publish -c $Configuration --verbosity quiet /nologo
Pop-Location

if ($LastExitCode -ne 0) {
  Write-Error 'Compilation failed.'
}

# Ensure out directory exists and is clean.
if (Test-Path $outDir) {
  Remove-Item -Path $outDir -Recurse -Force
}
New-Item -Path $outDir -ItemType Directory | out-null
New-Item -Path $outDeps -ItemType Directory | out-null
New-Item -Path $outCore -ItemType Directory | out-null
New-Item -Path $outDesktop -ItemType Directory | out-null

#Process markdown xml help
Write-Host -ForegroundColor Green 'Generate doc files ...'
$GenerateDocFilesS1 = (Join-Path $PSScriptRoot "generate-doc-files.ps1")
& $GenerateDocFilesS1

Write-Host -ForegroundColor Green 'Importing examples ...'
$ImportExamplesAndDescriptionsPS1 = (Join-Path $PSScriptRoot "import-examples.ps1")
& $ImportExamplesAndDescriptionsPS1

Write-Host -ForegroundColor Green 'Importing synopsis and descriptions ...'
$ImportSynopsisAndDescriptionsPS1 = (Join-Path $PSScriptRoot "import-synopsis-and-descriptions.ps1")
& $ImportSynopsisAndDescriptionsPS1

Write-Host -ForegroundColor Green 'Updating markdown files ...'
$UpdateMarkDownPS1 = (Join-Path $PSScriptRoot "update-markdown.ps1")
& $UpdateMarkDownPS1

Write-Host -ForegroundColor Green 'Creating new xml based help file ...'
$DocsPath = (Join-Path $PSScriptRoot "../docs/")
New-ExternalHelp -Path $DocsPath -OutputPath $PSScriptRoot -Force

# Update markdown xml by replacing place holders with actual descriptions for script based cmdlets.

# Place holder values for Find-MgGraphPermission
$SearchStringDescription = "The SearchString parameter allows you to specify a string such as 'user' or 'mail' that represents the subject or domain
of the permission you're searching for. Since permissions usually have names such as 'User.Read' or 'Mail.ReadWrite', the
command uses the SearchString parameter to return all permissions that contain the value specified for SearchString in the
name of the permission."

$ExactMatchDescription = "Specify the ExactMatch parameter to restrict the permissions emitted to those that exactly match the value specified for SearchString."

$PermissionTypeDescription = "Specify the PermissionType to determine whether application permissions, delegated permisisons, or both are returned by
Find-MgGraphPermission. By default, the value of this parameter is Any, which includes both delegated and application permissions.
Other valid values for PermissionType are Application and Delegated to return those specify types of permissions."

$OnlineDescription = "Specify the Online parameter in addition to SearchString to force Find-MgGraphPermission to update its set of permissions
by requesting the latest permissions data from Microsoft Graph itself before searching for the permissions specified the
SearchString parameter. This ensures that Find-MgGraphPermission returns the most accurate search results as new permissions
are added to Microsoft Graph for new APIs. The command uses the existing access to Microsoft Graph as enabled by a previous
invocation of the Connect-MgGraph command to issue the request for updated permissions. If your current connection does not
already have access to read this data from Microsoft Graph or if there is no network connectivity to Microsoft Graph, the command will fail.
If the command is successful in updating the set of permissions prior to searching for permissions, Find-MgGraphPermission will
continue to use the updated list for all future invocations of the command even if they do not specify the Online parameter"

$AllParameterDescription = "To return all possible permissions rather than just those that match the SearchString parameter, specify the All parameter. The
All parameter may also be used with the PermissionType to enumerate all applicaition permissions or all delegated permissions."

# Place holder values for Find-MgGraphCommand
$UriDescription = "The API path a command calls. e.g., /users."

$MethodDescription = "The HTTP method a command makes."

$ApiVersionDescription = "The service API version."

$CommandDescription = "The name of a command. e.g., Get-MgUser."

# Update maml file by replacing place holders with actual value.
(Get-Content "$cmdletsSrc/$ModulePrefix.$ModuleName-Help.xml") -replace "{{ Fill ApiVersion Description }}", $ApiVersionDescription -replace "{{ Fill Command Description }", $CommandDescription -replace "{{ Fill InputObject Description }}", "Pipeline input object" -replace "{{ Fill Uri Description }}", $UriDescription -replace "{{ Fill Method Description }}", $MethodDescription -replace "{{ Fill Command Description }}", $CommandDescription -replace "{{ Fill All Description }}", $AllParameterDescription -replace "{{ Fill Online Description }}", $OnlineDescription -replace "{{ Fill PermissionType Description }}", $PermissionTypeDescription -replace "{{ Fill SearchString Description }}", $SearchStringDescription -replace "{{ Fill ExactMatch Description }}", $ExactMatchDescription -replace "{{ Fill ProgressAction Description }}", "Treat this as a common parameter." | Set-Content "$cmdletsSrc/$ModulePrefix.$ModuleName-Help.xml"

# Update Find-MgGraphPermission markdown file by replacing place holders with actual value.
(Get-Content "$DocsPath/Find-MgGraphPermission.md") -replace "{{ Fill All Description }}", $AllParameterDescription -replace "{{ Fill Online Description }}", $OnlineDescription -replace "{{ Fill PermissionType Description }}", $PermissionTypeDescription -replace "{{ Fill SearchString Description }}", $SearchStringDescription -replace "{{ Fill ExactMatch Description }}", $ExactMatchDescription -replace "{{ Fill ProgressAction Description }}", "Treat this as a common parameter." | Set-Content "$DocsPath/Find-MgGraphPermission.md"

# Update Find-MgGraphCommand markdown file by replacing place holders with actual value.
(Get-Content "$DocsPath/Find-MgGraphCommand.md") -replace "{{ Fill ApiVersion Description }}", $ApiVersionDescription -replace "{{ Fill Command Description }", $CommandDescription -replace "{{ Fill InputObject Description }}", "Pipeline input object" -replace "{{ Fill Uri Description }}", $UriDescription -replace "{{ Fill Method Description }}", $MethodDescription -replace "{{ Fill Command Description }}", $CommandDescription -replace "{{ Fill ProgressAction Description }}", "Treat this as a common parameter."| Set-Content "$DocsPath/Find-MgGraphCommand.md"
# Copy manifest.
Copy-Item -Path "$cmdletsSrc/$ModulePrefix.$ModuleName.format.ps1xml" -Destination $outDir
Copy-Item -Path "$cmdletsSrc/$ModulePrefix.$ModuleName.psm1" -Destination $outDir
Copy-Item -Path "$cmdletsSrc/$ModulePrefix.$ModuleName.psd1" -Destination $outDir
Copy-Item -Path "$cmdletsSrc/StartupScripts" -Filter *.ps1 -Recurse -Destination $outDir

#Copy markdown xml help
Copy-Item -Path "$cmdletsSrc/$ModulePrefix.$ModuleName.dll-Help.xml" -Recurse -Destination $outDir
Copy-Item -Path "$cmdletsSrc/$ModulePrefix.$ModuleName-Help.xml" -Recurse -Destination $outDir
# Copy custom commands.
Copy-Item -Path "$cmdletsSrc/custom" -Recurse -Destination $outDir

# Core assemblies to include with cmdlets (Let PowerShell load them).
$CoreAssemblies = @('Microsoft.Graph.Authentication.Core')

# Copy each authentication.core asset to out directory and remember it.
$Deps = [System.Collections.Generic.HashSet[string]]::new()
Get-ChildItem -Path "$coreSrc/bin/$Configuration/$netStandard/publish/" |
Where-Object { $_.Extension -in $copyExtensions } |
Where-Object { -not $CoreAssemblies.Contains($_.BaseName) } |
ForEach-Object { [void]$Deps.Add($_.Name); Copy-Item -Path $_.FullName -Destination $outDeps -Recurse }

Get-ChildItem -Path "$coreSrc/bin/$Configuration/$netApp/publish/" |
Where-Object { -not $CoreAssemblies.Contains($_.BaseName) } |
ForEach-Object { [void]$Deps.Add($_.Name); Copy-Item -Path $_.FullName -Destination $outCore -Recurse }

Get-ChildItem -Path "$coreSrc/bin/$Configuration/$netFx/publish/" |
Where-Object { -not $CoreAssemblies.Contains($_.BaseName) } |
ForEach-Object { [void]$Deps.Add($_.Name); Copy-Item -Path $_.FullName -Destination $outDesktop -Recurse }

# Now copy each authentication asset, not taking any found in authentication.core.
Get-ChildItem -Path "$cmdletsSrc/bin/$Configuration/$netStandard/publish/" |
Where-Object { -not $Deps.Contains($_.Name) -and $_.Extension -in $copyExtensions } |
ForEach-Object { Copy-Item -Path $_.FullName -Destination $outDir -Recurse }

# Update module manifest with nested assemblies.
$RequiredAssemblies = @(
  'Microsoft.Graph.Authentication.dll', 
  'Microsoft.Graph.Authentication.Core.dll'
)
Update-ModuleManifest -Path (Join-Path $outDir "$ModulePrefix.$ModuleName.psd1") -NestedModules $RequiredAssemblies

Write-Host -ForegroundColor Green '-------------Done-------------'
